%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Jacobs Landscape Poster
% LaTeX Template
% Version 1.1 (14/06/14)
%
% Created by:
% Computational Physics and Biophysics Group, Jacobs University
% https://teamwork.jacobs-university.de:8443/confluence/display/CoPandBiG/LaTeX+Poster
% 
% Further modified by:
% Nathaniel Johnston (nathaniel@njohnston.ca)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[final]{beamer}

\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{etoolbox}
\usepackage{booktabs}
\AtBeginEnvironment{algorithm}{%
  \setlength{\columnwidth}{\linewidth}%
}

\usepackage[scale=1.24]{beamerposter} % Use the beamerposter package for laying out the poster
\usepackage{tipa}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usetheme{confposter} % Use the confposter theme supplied with this template
\usepackage{sidecap}
\setbeamercolor{block title}{fg=ngreen,bg=white} % Colors of the block titles
\setbeamercolor{block body}{fg=black,bg=white} % Colors of the body of blocks
\setbeamercolor{block alerted title}{fg=white,bg=dblue!70} % Colors of the highlighted block titles
\setbeamercolor{block alerted body}{fg=black,bg=dblue!10} % Colors of the body of highlighted blocks
% Many more colors are available for use in beamerthemeconfposter.sty

%-----------------------------------------------------------
% Define the column widths and overall poster size
% To set effective sepwid, onecolwid and twocolwid values, first choose how many columns you want and how much separation you want between columns
% In this template, the separation width chosen is 0.024 of the paper width and a 4-column layout
% onecolwid should therefore be (1-(# of columns+1)*sepwid)/# of columns e.g. (1-(4+1)*0.024)/4 = 0.22
% Set twocolwid to be (2*onecolwid)+sepwid = 0.464
% Set threecolwid to be (3*onecolwid)+2*sepwid = 0.708

\newtheorem{proposition}{Proposition}

\newlength{\sepwid}
\newlength{\onecolwid}
\newlength{\twocolwid}
\newlength{\threecolwid}
\setlength{\paperwidth}{76in} % A0 width: 46.8in
\setlength{\paperheight}{35in} % A0 height: 33.1in
\setlength{\sepwid}{0.024\paperwidth} % Separation width (white space) between columns
\setlength{\onecolwid}{0.22\paperwidth} % Width of one column
\setlength{\twocolwid}{0.464\paperwidth} % Width of two columns
\setlength{\threecolwid}{0.708\paperwidth} % Width of three columns
\setlength{\topmargin}{-0.5in} % Reduce the top margin size
%-----------------------------------------------------------

\usepackage{etoolbox}
\makeatletter
\patchcmd{\beamer@@tmpl@headline}{wd=47in}{wd=71in}{}{}
\makeatother

\usepackage{graphicx}  % Required for including images
\usepackage{verbatim}
\usepackage{booktabs} % Top and bottom rules for tables
\usepackage{fancyvrb}

\begin{SaveVerbatim}[]{ListSketch}
Program ::=
  (if Bool List
    (append RecursiveList
            RecursiveList
            RecursiveList))
Bool ::= (<= Int) | (>= Int)
Int  ::= 0 | (1+ Int) | (1- Int)
       | (length List) | (head List)
List ::= nil | (filter Bool List)
      | X | (tail List) | (list Int)
RecursiveList ::= List
                | (recurse List)
\end{SaveVerbatim}

\begin{SaveVerbatim}[]{TextSketch}
Program ::= Term | Program + Term
Term    ::= String | substr(Pos,Pos)
Pos     ::= Number
         |  pos(String,String,Number)
Number  ::= 0 | 1 | 2 | ... 
         | -1 | -2 | ...
String  ::= Character 
         |  Character + String
Character ::= a | b | c | ...
\end{SaveVerbatim}



\usepackage{wrapfig}

%----------------------------------------------------------------------------------------
%	TITLE SECTION 
%----------------------------------------------------------------------------------------
\usepackage{stmaryrd}
\newcommand{\tuple}[1]{\ensuremath{\left \langle #1\right \rangle}}
\newcommand{\sem}[1]{[\mkern-6mu[#1]\mkern-6mu]} %\newcommand{\sem}[1]{\llbracket #1\rrbracket}

\usetikzlibrary{trees}
\usetikzlibrary{fit}
\usetikzlibrary{calc}
\usetikzlibrary{bayesnet}

\usepackage[normalem]{ulem}
\newcommand{\theSystem}{\textsc{ProgramSample}}
\title{Sampling for Bayesian Program Learning} % Poster title

\author{Kevin Ellis, Armando Solar-Lezama, and Joshua B. Tenenbaum} % Author(s)

\institute{Massachusetts Institute of Technology} % Institution(s)

%----------------------------------------------------------------------------------------

\begin{document}
\addtobeamertemplate{headline}{} 
{\begin{tikzpicture}[remember picture, overlay]
     \node [anchor=north east, inner sep=3cm]  at (current page.north east)
           {\includegraphics[height=7cm]{csail.png}};
                \node [anchor=north west, inner sep=3cm]  at (current page.north west)
     {\includegraphics[height=5cm]{bcs.png}};
\end{tikzpicture}}

\addtobeamertemplate{block end}{}{\vspace*{2ex}} % White space under blocks
\addtobeamertemplate{block alerted end}{}{\vspace*{2ex}} % White space under highlighted (alert) blocks

\setlength{\belowcaptionskip}{2ex} % White space under figures
\setlength\belowdisplayshortskip{2ex} % White space under equations

\begin{frame}[t] % The whole poster is enclosed in one beamer frame

\begin{columns}[t] % The whole poster consists of three major columns, the second of which is split into two columns twice - the [t] option aligns each column's content to the top

\begin{column}{\sepwid}\end{column} % Empty spacer column

\begin{column}{\onecolwid} % The first column

%----------------------------------------------------------------------------------------
%	OBJECTIVES
%----------------------------------------------------------------------------------------

\begin{alertblock}{Problem statement}
  \textbf{Bayesian Program Learning:} Learn programs from input/output examples, framed as Bayesian inference.
  Given a prior over programs, condition on examples. 
  In this work we approximate the posterior by a set of samples.

  \begin{itemize}
  \item \textbf{Efficient in practice}: synthesizes non-trivial programs in minutes
  \item \textbf{Theoretical guarantees}: our algorithm, \theSystem , generates iid samples from a distribution that provably approximates the true posterior 
    \end{itemize}

Sampling text edit programs:
  
\centering\begin{tikzpicture}
\node[draw,rounded corners](problem)
     {\begin{tabular}{lr}
      Input & Output \\\hline
      ``1/21/2001'' & ``01''
     \end{tabular}};
\node[draw,rounded corners](sampledPrograms) at (0,-7)
     {\begin{tabular}{lr}
         A sampled program & English interpretation\\\hline
         {\ttfamily\small \hspace{-\mylength}substr(pos('0',-1),-1)} & ``last 0 til end'' \\
      {\ttfamily\small \hspace{-\mylength}const('01')}       & ``output 01''\\
      {\ttfamily\small \hspace{-\mylength}substr(-2,-1)} & ``take last two''
     \end{tabular}};
\draw[->,thick](problem.south) -- (sampledPrograms.north);
\end{tikzpicture}



\end{alertblock}

\begin{block}{Two Key Ingredients}
  How can we get both practical  performance and theoretical guarantees for a problem that feels so obviously intractable? Combine two ideas:
  \begin{itemize}
\item \textbf{Sketching:} The program's high-level structure is
  already given as a \emph{sketch}, like a recursive grammar over
  expressions. Consider \emph{finite} programs (bounded size, bounded
  runtime, bounded memory consumption), which can be modeled in a
  constraint solver: this does the heavy lifting of searching for programs. Here we use a SAT solver.
\item \textbf{Sampling via random XOR constraints:} Once a program learning problem has been converted to SAT,
  we can sample programs (SAT solutions) by adding random XOR constraints to the SAT formula,
an idea first introduced in Gomes et al.~\cite{gomes2006near}.
    \end{itemize}
  \end{block}

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\begin{block}{Problem Framing}
\begin{itemize}
\item Sketch specifies a large but finite set of programs, $S$
\item Program description length: $\lvert x \rvert$ for $x\in S$
\item Prior over programs: $\propto 2^{- \lvert x \rvert }$
\item Posterior over programs: call this $p(x)$, defined as $\propto 2^{- \lvert x \rvert } \mathds{1}[x \text{ consistent with input/output examples}]$
\end{itemize}
Our goal then  is to sample from $p(\cdot)$.
\end{block}

%------------------------------------------------

\begin{block}{Our solution}
%  The space of all programs is vast and often unamenable to the optimization methods used in much of machine learning.
We extend two ideas from the program synthesis community to make search over programs tractable:

\textbf{Sketching:} Manually provide a \emph{sketch}, or rough outline, of the program to be induced~\cite{solar2008program}.
Our sketches are probabilistic context-free grammars.


\textbf{Symbolic search:} %Much progress has been made in the engineering of general-purpose symbolic solvers for Satisfiability Modulo Theories (SMT) problems.
We automatically translate our sketches into Satisfiability Modulo Theories (SMT) problems.
%This is nontrivial because it involves converting the soft constraints of a probabilistic model
%into the hard constraints accepted by SMT solvers.
SMT problems are intractable in general, but often solved efficiently in practice, much like SAT problems.% due to the highly constrained nature of program synthesis which these solvers can exploit.
\vspace{2cm}
\begin{tikzpicture}\centering
  \node (g) at (0,0) {\normalsize Sketch};
  \node (n) at (10,-5) {\normalsize Noise model};
  \node[draw,align=center] (u) at (10,0) {\normalsize Unsupervised\\Program\\Synthesis};
  \node[draw,align=center] (s) at (20,0) {Synthesizer\\(SMT)};
  \node (d) at (20,-5) {Data};
  \node (p) at (30,0) {Program};
  \draw[->] (u) to  (s);
    \draw[->] (s) to  (p);
  \draw[->] (d) to  (s);
      \draw[->] (n) to  (u);
      \draw[->] (g) to  (u);
\end{tikzpicture}

  \end{block}

%----------------------------------------------------------------------------------------

\end{column} % End of the first column

\begin{column}{\sepwid}\end{column} % Empty spacer column

\begin{column}{\twocolwid} % Begin a column which is two columns wide (column 2)

\begin{columns}[t,totalwidth=\twocolwid] % Split up the two columns wide column

\begin{column}{\onecolwid}\vspace{-.6in} % The first column within column 2 (column 2.1)

%----------------------------------------------------------------------------------------
%	MATERIALS
%----------------------------------------------------------------------------------------
%

%%  \begin{alertblock}{Bayesian Program Learning \& other approaches} %
    %% Why might a learner represent knowledge as a program,
    %% rather than the representations popular in much of machine learning,
    %% such as a large matrix of weights or a graphical model?
    %% Programs (probabilistic or deterministic)
    %% excel at representing knowledge that is (1) symbolic; (2) compositional; or (3) higher-order.
    %% We are motivated by the success of program induction
    %% in both AI domains,
    %% like semantic parsing and programming by demonstration,
    %% and in cognitive modeling,
    %% like intuitive theory learning~\cite{logical}.
%%\end{alertblock}
  
  \begin{block}{Background: Program Synthesis by SAT Solving}

\hspace{-2.5cm}\includegraphics[width=45cm]{background.png}
  \end{block}

  \begin{block}{Sampling by Random XOR Constraints}
Embed $X$ within a larger set $E$ where sampling uniformly from $E$ samples from $  q(x) \propto     2^{-\text{min}(\lvert x \rvert,d) }$, where $d$ bounds the tilt of $q(\cdot)$:
  \begin{equation}
    E = \{(x,y) \text{ }:\text{ } x\in X,  \bigwedge_{1\leq j \leq d} \lvert x \rvert \geq j\Rightarrow y_j=1 \}
  \end{equation}
  Sample approximately uniformly from $E$ by fixing the parity of random sums (XOR's) of SAT variables. Use $K$ such sums. \# satisfying members of $E$ is $\approx 2^{-K}|E|$. Accept sample w.p. $A(x) = \min (1,2^{-|x| + d})$ to correct for $q(\cdot)$.

\vspace{0.9cm}
  \begin{tabular}{cl}
    \begin{tabular}{c}
      \includegraphics[width=25cm]{cartoon_small.png} 
    \end{tabular}&
    \begin{tabular}{l}
      \parbox{15cm}{\emph{Summary}: Approximate $p(x)$ by $q(x)$, embed in $E$, approximately uniform samples of $E$ give $r(x)$, distribution of samples is $\propto A(x)r(x)$}
      \end{tabular}
    \end{tabular}

  \end{block}
  

\textbf{Proposition 1: Distribution of samples is close in KL to true posterior.}
    Write $Ar(x)$ to mean the distribution of the samples. Then $D(p||Ar)<\log \left( 1 + \frac{1 + 2^{ - \gamma}}{1 + 2^\Delta}\right)$.


    \textbf{Proposition 2: Not too much work needed to get a provably correct sample.}
    The expected number of calls to the solver per sample is bounded above by $\frac{1 + 2^\Delta}{(1 + 2^{ - \gamma})^{-1}(1 + 2^{ - \Delta})^{-1} - 2^{ - \Delta}}.$

  \end{block}

%----------------------------------------------------------------------------------------

\end{column} % End of column 2.1

\begin{column}{\onecolwid}\vspace{-.6in} % The second column within column 2 (column 2.2)

%----------------------------------------------------------------------------------------
%	METHODS
%----------------------------------------------------------------------------------------

\begin{block}{Domain: Learning text edit scripts}

  \textbf{Programming By Example }: Learn a string editing program from a few examples. A practical and timely problem. Systems like this ship in Excel~\cite{gulwani2011automating}.
  Two PBE problems and a program we learn from them:

  \vspace{1cm}
  
  \begin{tabular}{lr}\toprule
  \textbf{Examples} & \textbf{A program}\\\midrule
\\\begin{tabular}{l|r}
  Input & Output \\\hline
don steve g.&dsg\\
Kevin Jason Mat&KJM\\
Jose Larry S&JLS\\
Arthur Joe Juan&AJJ\\
Raymond F. Timothy &RFT
\end{tabular}&
\begin{tabular}{l}
  \parbox{25cm}{  \texttt{SubStr(0,1)+}
    \\\texttt{SubStr(Pos(' ','',0),Pos(' ','',0))+}
    \\\texttt{SubStr(Pos(' ','',-1),Pos(' ','',1))} }
\end{tabular}
\\\\
\begin{tabular}{l|r}Input & Output \\\hline
12/31/13&12.31\\
1/23/2009&1.23\\
4/12/2023&4.12\\
6/23/15&6.23\\
7/15/2015&7.15
\end{tabular}&
\begin{tabular}{l}
  \parbox{25cm}{  \texttt{SubStr(0,Pos('','/',0))+} \\
    \texttt{Constant('.')+}
    \\\texttt{SubStr(Pos('/','',0),Pos('','/',-1))}}
\end{tabular}

\\\\\bottomrule
  \end{tabular}

\vspace{1cm} \textbf{ Key problem}: PBE systems target end-users who are unwilling to provide more than one or a few examples, so target behavior is highly ambiguous. Model this ambiguity using sampling!
\end{block}

\begin{block}{Sketching a Program Space}
\centering\BUseVerbatim[fontfamily=courier]{TextSketch}
\end{block}

\begin{block}{Learning from very few examples}
\begin{figure}[h]\centering
  \begin{minipage}{0.45\textwidth}\centering
    \includegraphics[width=\textwidth]{smallFractionSolving.png}
  \caption{Generalization when learning text edit operations by example. Results averaged across 19 problems. Solid: 100 samples from \theSystem{} . Dashed: enumerating 100 programs. Dotted: MDL learner.}\label{flashPerformance}        \end{minipage}%
\hspace{0.025\textwidth}\begin{minipage}{0.45\textwidth}\centering
    \includegraphics[width=0.7\textwidth]{small_mdl.png}
    \caption{Comparing the MDL learner (dashed black line) to program sampling when doing one-shot learning. We count a problem as ``solved'' if  the correct joint prediction to the test cases is in the top $C$ most frequent samples.}\label{mdl}
  \end{minipage}
\end{figure}

\textbf{Multiple explanations aids one-shot learning.} After a single example, the shortest program is probably not correct -- but one of the top sampled \emph{behaviors} (marginalizing over the program) might be.

\textbf{Good performance needs tilt correction.} w/o low-tilt approximation, get no samples for any of these problems after an hour, vs $\approx 1$ minute w/ \theSystem



\end{block}

%% \begin{block}{The Cost of Sampling}
%%   Amortized cost of 100 samples from \theSystem :
  
%%   \vspace{1cm}

%%   \hspace{9cm}\vspace{1cm}    \begin{tabular}{lll}\toprule
%%      1 example\hspace{0.9cm}      &  2 examples\hspace{0.9cm}          &     3 examples\\\midrule
%% $84 \pm 3$ sec &$21 \pm 1$ sec & $49\pm 3$ sec
%% \end{tabular}

%% \textbf{Good performance needs tilt correction.} w/o low-tilt approximation, get no samples for any of these problems after an hour!

%% \textbf{Can closely approximate posterior with little overhead.}

%% %\vspace{-2.5cm}
%% \begin{tabular}{cl}
%%   \begin{tabular}{c}
%%     \includegraphics[width=25cm]{trim-trade-off.png}
%%     \end{tabular}&
%%   \begin{tabular}{l}
%%     \parbox{15cm}{Accuracy (colored contours) vs Performance (monochrome cells) trade-off; upper bounds plotted. Performance measured in expected solver invocations; accuracy measured in log KL divergence.}
%%     \end{tabular}
%% \end{tabular}
%% %\end{figure}

%%   \end{block}
%----------------------------------------------------------------------------------------

\end{column} % End of column 2.2

\end{columns} % End of the split of column 2 - any content after this will now take up 2 columns width


%----------------------------------------------------------------------------------------

\begin{columns}[t,totalwidth=\twocolwid] % Split up the two columns wide column again

\begin{column}{\onecolwid} % The first column within column 2 (column 2.1)

%----------------------------------------------------------------------------------------
%	MATHEMATICAL SECTION
%----------------------------------------------------------------------------------------



%----------------------------------------------------------------------------------------

\end{column} % End of column 2.1

\begin{column}{\onecolwid} % The second column within column 2 (column 2.2)

%----------------------------------------------------------------------------------------
%	RESULTS
%----------------------------------------------------------------------------------------


%----------------------------------------------------------------------------------------

\end{column} % End of column 2.2

\end{columns} % End of the split of column 2

\end{column} % End of the second column

\begin{column}{\sepwid}\end{column} % Empty spacer column

\begin{column}{\onecolwid} % The third column

%----------------------------------------------------------------------------------------
%	CONCLUSION
%----------------------------------------------------------------------------------------

  \begin{block}{Domain: List Manipulation}
    \textbf{Computer Aided Programming}: Synthesize source code consistent with a specification.
    We tackle these problems:
    \begin{itemize}
    \item \textbf{Sort}: synthesize quicksort
    \item \textbf{Reverse}: recursively reverse a list
    \item \textbf{Count}: count occurrences of list head in list tail
    \end{itemize}
    In general multiple implementations will satisfy the spec, especially when the spec consists of examples.
    Model the ambiguity by sampling plausible implementations.

  \end{block}

  \begin{block}{Sketching a Program Space}
    \centering\BUseVerbatim[fontfamily=courier]{ListSketch}
  \end{block}

%----------------------------------------------------------------------------------------
%	ADDITIONAL INFORMATION
%----------------------------------------------------------------------------------------

\begin{block}{Learner Generalizes to Longer Sequences}
  Trained to sort, reverse, or count on lists of length $\leq 3$; tested on lists of length $\leq 14$.
  
    \includegraphics[width=\textwidth]{tinyList.png}

    \textbf{Sampling aids generalization.} Even if the most likely program has a bug, the posterior puts enough mass on correct programs that the ensemble of samples acts as a probabilistic algorithm with a high probability of succeeding.
    
\end{block}

%----------------------------------------------------------------------------------------
%	REFERENCES
%----------------------------------------------------------------------------------------

\setbeamercolor{block title}{fg=red,bg=white} % Change the block title color
%% \begin{block}{References}

%%   %\nocite{*} % Insert publications even if they are not cited in the poster
%%   \renewcommand{\refname}{\vspace{-0.8em}}
%%           \bibliographystyle{plain}
%%           \bibliography{main}
%% %\small{\bibliographystyle{plain}
%% %\bibliography{main}}

%% \end{block}

%----------------------------------------------------------------------------------------
%	ACKNOWLEDGEMENTS
%----------------------------------------------------------------------------------------

\setbeamercolor{block title}{fg=red,bg=white} % Change the block title color

\begin{block}{Acknowledgements}

\small{\rmfamily{We are grateful for feedback from Adam Smith, Kuldeep Meel, and our anonymous reviewers.
Work supported by AFOSR award FA9550-16-1-0012.}} \\

\end{block}

%----------------------------------------------------------------------------------------
%	CONTACT INFORMATION
%----------------------------------------------------------------------------------------


%----------------------------------------------------------------------------------------

\end{column} % End of the third column

\end{columns} % End of all the columns in the poster

\end{frame} % End of the enclosing frame

\end{document}

