// The original approach that I tried was to not have an embedding
// We would then sample uniformly over assignments to the sat variables
// This would give sampling from the description length prior.
// But it's very inefficient!
//#define ORIGINALAPPROACH

#define PIECES 3
#define PIECESIZE 59
#define TAPELENGTH (PIECESIZE*PIECES+PIECES-1)
//#define 
bit[TAPELENGTH] tape = ??;
bit[EMBEDDINGLENGTH] auxiliary = ??;

int tape_index = 0;


int max(int a,int b) {
  return a > b ? a : b;
}

bit flip() {
  return tape[tape_index++];
}


int random_number() {
  bit b1 = flip();
  bit b2 = flip();
  bit b3 = flip();
  bit b4 = flip();

  return 8*b1 + 4*b2 + 2*b3 + 1*b4;
}


char random_character() {
  bit b1 = flip();
  bit b2 = flip();
  bit b3 = flip();
  bit b4 = flip();
  bit b5 = flip();
  bit b6 = flip();

  return 32*b1 + 16*b2 + 8*b3 + 4*b4 + 2*b5 + 1*b6;
}

  
int random_little_number() {
  bit b1 = flip();
  bit b2 = flip();
  return 2*b1 + 1*b2;
}



struct str{    
    int n; char[n] ch;    
}

str cstr([int n] , char[n] ch){
  return new str(n=n-1, ch=ch[0::(n-1)]);
}

// s = ...r1r2...
// returns  ^ position
// optionally skip over k occurrences
int Pos([int n1, int n2], str s, char[n1] r1, char[n2] r2, int k ){
  int saved;
  bit foundit = 0;
  
  assert n1 > 0 || n2 > 0;
  for (int i=0; i<s.n; ++i){
    if(i+ n1 + n2 < s.n){
      if(s.ch[i::n1]==r1 && s.ch[(i+n1)::n2] == r2){
	if(k==0){
	  return i+ n1;
	}else{
	  if (k < 3) k--;
	  else { // k == 3
	    foundit = 1;
	    saved = i + n1;
	  }
	}
      }
    }
  }
  assert foundit;
  return saved;
}

str SubStr(str s, int p1, int p2){
  if (p2 == p1) p2 = p1 + 1;
  assert p2 > p1;
  assert p1 >= 0;
  assert p2 >= 0;
  assert p2-p1 <= s.n;
  return new str(n=p2-p1, ch=s.ch[p1:p2]);
}

str Concat(str s1, str s2){
  char[s1.n + s2.n] ch;
  ch[0::s1.n] = s1.ch;
  ch[s1.n::s2.n] = s2.ch;
  return new str(n = s1.n+s2.n, ch = ch);
}

str genExpr(str s, ref int mdl){
  mdl = 0;

  void spend(int b) {
    mdl += b;
  }

  bit canConstant = 1;
  bit haveBadPosition = 0;
  int badPosition = 0;
  
  str term() { //ref bit canConstant, ref int bannedPosition){
    char[3] r1 = {random_character(),random_character(),random_character()};
    char[3] r2 = {random_character(),random_character(),random_character()};
    int r1l = random_little_number();
    int r1l_p = random_little_number();
    int r2l = random_little_number();
    int r2l_p = random_little_number();

    int p1_k = random_number();
    int p2_k = random_number();

    bit k1 = flip();
    bit k2 = flip();

    int p1_occurrence = random_little_number();
    int p2_occurrence = random_little_number();

    // produce all the holes that once
    spend(1);
    if(flip()){
      haveBadPosition = 0; // any following position is fine
      
      assert r1l > 0;
      assert canConstant;
      canConstant = r1l == 3;
      
      spend(r1l*6 + 2);

if (!ORIGINALAPPROACH) {
      assert r2[0] == 0 && r2[1] == 0 && r2[2] == 0;
      if (r1l < 3) assert r1[2] == 0;
      if (r1l < 2) assert r1[1] == 0;
      assert r1l_p == 0;
      assert r2l == 0;
      assert r2l_p == 0;
      assert p1_k == 0;
      assert p2_k == 0;
      assert k1 == 0;
      assert k2 == 0;
      assert p1_occurrence == 0;
      assert p2_occurrence == 0;
}
      return new str(n = r1l, ch = r1[0::r1l]);
    } else {
      canConstant = 1;

      assert r2l < 3 && r1l < 3;
      assert r2l_p < 3 && r1l_p < 3;

      // bound the specificity of patterns
      assert r1l+r2l < 4;
      assert r1l_p+r2l_p < 4;
      
      spend(2 + 4 + 4); // choices k1,k2, inevitable 4 bits for each branch
      
      int effective_r1l = 0;
      int effective_r2l = 0;
      
      int p1;
      if (k1) {
if (!ORIGINALAPPROACH) {
	assert r1l == 0 && r2l == 0 && p1_occurrence == 0;
}
	//spend(4);
	p1 = p1_k;
	// if the position is greater than 7,
	// then the high bit is one
	if (p1 > 7) p1 = s.n - p1 + 8;
      } else {
	spend(2);
	//spend(2+2+2); // r1l,r2l,p1_occurrence
if (!ORIGINALAPPROACH) {
	assert p1_k == 0;
}
	effective_r1l = max(effective_r1l,r1l);
	effective_r2l = max(effective_r2l,r2l);
	p1 = Pos(s, r1[0::r1l], r2[0::r2l], p1_occurrence);
      }

      int p2;
      if (k2) {
	//spend(4);
if (!ORIGINALAPPROACH) {
	assert r1l_p == 0 && r2l_p == 0 && p2_occurrence == 0;
}
	p2 = p2_k;
	if (p2 > 7) p2 = s.n - p2 + 8;
      } else {
	//spend(6);
	spend(2);
	assert p2_k == 0;
	effective_r1l = max(effective_r1l,r1l_p);
	effective_r2l = max(effective_r2l,r2l_p);
	p2 = Pos(s, r1[0::r1l_p], r2[0::r2l_p], p2_occurrence);
      }

      if (haveBadPosition)
	assert p1 != badPosition || (p1 == p2);

      if (p1 != p2) {
	haveBadPosition = 1;
	badPosition = p2;
      } else {
	haveBadPosition = 0;
      }
if (!ORIGINALAPPROACH) {
      if (effective_r1l < 3) assert r1[2] == 0;
      if (effective_r1l < 2) assert r1[1] == 0;
      if (effective_r1l < 1) assert r1[0] == 0;

      if (effective_r2l < 3) assert r2[2] == 0;
      if (effective_r2l < 2) assert r2[1] == 0;
      if (effective_r2l < 1) assert r2[0] == 0;
}
      
      spend(effective_r1l*6);
      spend(effective_r2l*6);
      
      return SubStr(s, p1, p2); 
    }
  }

  str out = term();
  spend(1);
  if (flip()) {
if (!ORIGINALAPPROACH) {
    repeat (TAPELENGTH - PIECESIZE*1 - 1) { assert flip() == 0; }
}
    return out;
  }
  out = Concat(out,term());
  spend(1);
  if (flip()) {
if (!ORIGINALAPPROACH) {
    repeat (TAPELENGTH - PIECESIZE*2 - 2) { assert flip() == 0; }
}
    return out;
  }
  out = Concat(out,term()); 
  return out;
}

str flashToy(str s){
  int mdl;
  tape_index = 0;
  str o =  genExpr(s,mdl);

  assert mdl >= SHORTEST;
  //  assert mdl - MAXIMUMLENGTH;
  
  int embedding_index = 0;
  repeat (EMBEDDINGLENGTH) {
    if (mdl > embedding_index) assert auxiliary[embedding_index];
    embedding_index++;
  }

  return o;
}



bit eq(str s1, str s2){
  return s1.ch == s2.ch;
  if (s1.n != s2.n) return 0;
  for (int j = 0; j < s1.n; j++)
    if (s1.ch[j] != s2.ch[j]) return 0;
  return 1;
}

void testCase([int n,int m],char [n] i, char[m] o){
  assert eq(cstr(o),flashToy(cstr(i)));
}


//harness void main() {
//#include "flashProblems.h"

  /*  int embedding_index = 0;
  repeat (EMBEDDINGLENGTH) {
    if (embedding_index < SHORTEST) assert auxiliary[embedding_index];
    embedding_index++;
    }*/
//}

