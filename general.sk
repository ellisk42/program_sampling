pragma options "--bnd-unroll-amnt 3 --bnd-arr1d-size 3 --bnd-arr-size 3";

#define LISTLENGTH 3 // train on lists of up to length

//  --bnd-int-range 10

#define BOUND 64 //143
#define MAXIMUMLENGTH 64 // maximum description length
#define MAXIMUMNUMBER LISTLENGTH // maximum number manipulated by program

bit[BOUND] tape = ??;
int tape_index = 0;
// guard length = 2, always
// array length = {?,1,6,15}
// integer l =    {?,0,4,13}

#define ANALYZING

#ifndef ANALYZING
#define SHORTEST 43
#define EMBEDDINGLENGTH (SHORTEST+11) //(19+13) //(30-SHORTEST)
bit[EMBEDDINGLENGTH] auxiliary = ??;
#endif


#define O_EQ 0
#define O_LT 1
#define O_GT 2
struct Guard {
  int z;
  int o;
}

bit run_guard(Guard g, int z) {
  if (g.o == O_EQ) return z == g.z;
  if (g.o == O_LT) return z <= g.z;
  if (g.o == O_GT) return z >= g.z;
  assert 0;
}

bit flip() {
  bit b = tape[tape_index];
  tape_index++;
  return b;
}

int validate_number(int x) {
  assert x >= 0 && x < (MAXIMUMNUMBER+1);
  return x;
}

struct Array{
  int s;
  int [s] A;
}

 
bit array_equal(Array a,Array b) {
  if (a.s != b.s) return 0;
  for (int j = 0; j < a.s; j++)
    if (a.A[j] != b.A[j]) return 0;
  return 1;
}


Array concatenate(Array a1,Array a2) {
  Array a = new Array(s = a1.s + a2.s,A = a1.A);
  a.A[a1.s :: a2.s] = a2.A;
  return a;
}


Array concatenate3(Array a1,Array a2,Array a3) {
  assert a1 != null;
  assert a2 != null;
  assert a3 != null;
  /*  assert a1.s + a2.s + a3.s >= 0;*/
  int l = validate_number(validate_number(a1.s) + validate_number(a2.s) + validate_number(a3.s));
  int[l] x;
  x[0 :: a1.s] = a1.A;
  x[a1.s :: a2.s] = a2.A;
  x[(a2.s+a1.s) :: a3.s] = a3.A;
  return new Array(s = l,A = x);
}

Array cdr(Array a,ref bit success) {
  if (a.s == 0) {
    success = 0;
    return a;
  }
  success = 1;
  return new Array(s = a.s-1, A = a.A[1 :: (a.s-1)]);
}

Array filter(Guard g, Array a) {
  int outsz = 0;
  int [a.s] out;
  for (int i=0; i<a.s; ++i){
    if (run_guard(g,a.A[i])) {
      out[outsz++] = a.A[i];
    }
  }
  return new Array(s=outsz, A=out[0::outsz]);
}

Array singleton(int n) {
  return new Array(s = 1,A = {n});
}

int car(Array a,ref bit success) {
  success = 1;
  if (a.s > 0) return a.A[0];
  success = 0;
  return 0;
}

Array empty_list() {
  return new Array(s = 0,A = {});
}

void force_zero_guard(int d) {
  int j = 0;
  repeat (2) { assert tape[tape_index + (j++)] == 0; } 
}

Guard guard_expression(int z,int d,ref bit success,ref int mdl) {
  success = 1;

  bit c1 = flip();
  bit c2 = flip();
  int o = O_EQ; // do I need to set this?
  if (c1 && c2) o = O_EQ;
  if (c1 && !c2) success = 0;
  if (!c1 && c2) o = O_LT;
  if (!c1 && !c2) o = O_GT;

  mdl += 2; // choice of operator
  assert mdl < MAXIMUMLENGTH;
  
  return new Guard(z = z, o = o);
}

void force_zero_array(int d) {
  assert d > 0;
  int j = 0;
  if (d == 1) { repeat (1) { assert tape[tape_index + (j++)] == 0; } }
  else if (d == 2) { repeat (6) { assert tape[tape_index + (j++)] == 0; } }
  else if (d == 3) { repeat (15) { assert tape[tape_index + (j++)] == 0; } }
  else assert 0;
}

Array array_expression(Array a,int d,ref bit success,ref bit single,ref bit empty,ref int mdl) {
  single = 0;
  empty = 0;
  
  assert d > 0;

  bit c1 = flip();
  if (d == 1) { // only terminals allowed
    mdl++;
    assert mdl < MAXIMUMLENGTH;
    success = 1;
    if (c1) {
      empty = 1;
      return empty_list();
    } else {
      return a;
    }
  }
  

  bit c2 = flip();
  bit c3 = flip();

  bit array_success,array_single,array_empty;
  int array_mdl = 0;
  if (!((c1 && !c2 && c3) || (!c1 && c2 && c3))) {
    force_zero_array(d-1);
  }
  Array lp = array_expression(a,d-1,array_success,array_single,array_empty,array_mdl);
  
  
  bit integer_success,integer_increment,integer_decrement;
  int integer_mdl = 0;
  if (!((c1 && !c2 && !c3) || (!c1 && c2 && c3))) {
    force_zero_integer(d-1);
  }
  int z = integer_expression(a,d-1,integer_success,integer_increment,integer_decrement,integer_mdl);

  bit cdr_success;
  
  bit guard_success;
  int guard_mdl = 0;
  Guard g;
  if (!(!c1 && c2 && c3)) {
    force_zero_guard(d-1);
  }
  g = guard_expression(z,d-1,guard_success,guard_mdl);
  
  // pay for the choice
  mdl += 3;
  assert mdl < MAXIMUMLENGTH;

  if (c1 && c2 && c3) {
    empty = 1;
    success = 1;
    return empty_list();
  }
  if (c1 && c2 && !c3) {
    success = 1;
    return a;
  }
  if (c1 && !c2 && !c3) {
    single = 1;
    mdl += integer_mdl;
    assert mdl < MAXIMUMLENGTH;
    success = integer_success;
    return singleton(z);
  }
  mdl += array_mdl;
  assert mdl < MAXIMUMLENGTH;
  if (c1 && !c2 && c3) {
    if (array_success) {
      Array r = cdr(lp,cdr_success);
      success = cdr_success && !array_single;
      return r;
    }
    success = 0;
    return empty_list();
  }
  
  if (!c1 && c2 && c3) {
    mdl += guard_mdl + integer_mdl;
    success = integer_success && array_success && guard_success && !array_empty;
    return filter(g,lp);
  }
  success = 0;
  return empty_list();
}

void force_zero_integer(int d) {
  assert d > 0;
  if (d == 1) return;

  int j = 0;
  if (d == 2) { repeat (4) { assert tape[tape_index + (j++)] == 0; } }
  else if (d == 3) { repeat (13) { assert tape[tape_index + (j++)] == 0; } }
  else assert 0;
}


int integer_expression(Array a,int d,ref bit success,ref bit incremented,ref bit decremented,ref int mdl) {
  incremented = 0;
  decremented = 0;
  
  assert d > 0;
  if (d == 1) { success = 1; return 0; }

  bit c1 = flip();
  bit c2 = flip();
  bit c3 = flip();
  mdl += 3;
  assert mdl < MAXIMUMLENGTH;
  
  bit integer_success,integer_incremented,integer_decremented;
  int integer_mdl = 0;
  if (!((c1 && c2 && !c3) || (c1 && !c2 && c3))) {
    force_zero_integer(d-1);
  }
  int zp = validate_number(integer_expression(a,d-1,integer_success,integer_incremented,integer_decremented,integer_mdl));
  
  bit array_success,array_empty,array_single;
  int array_mdl = 0;
  if (!((c1 && !c2 && !c3) || (!c1 && c2 && c3))) {
    force_zero_array(d-1);
  }
  Array l = array_expression(a,d-1,array_success,array_empty,array_single,array_mdl);


  if (c1 && c2 && c3) { success = 1; return 0; }
  if (c1 && c2 && !c3) { assert mdl < MAXIMUMLENGTH; mdl += integer_mdl; success = integer_success && !integer_decremented; return validate_number(zp+1); }
  if (c1 && !c2 && c3) { assert mdl < MAXIMUMLENGTH; mdl += integer_mdl; success = integer_success && !integer_incremented; return validate_number(zp-1); }
  mdl += array_mdl;
  assert mdl < MAXIMUMLENGTH;
  if (c1 && !c2 && !c3) {
    if (array_success) {
      bit car_success;
      int r = validate_number(car(l,car_success));
      success = car_success && !array_single && !array_empty; 
      return r;
    }
    success = 0;
    return 0;
  }
  if (!c1 && c2 && c3) {
    success = array_success && !array_single && !array_empty;
    return validate_number(l.s);
  }
  success = 0;
  return 0;
}

Array recursive_expression(Array a, int bnd, ref int mdl) {
  mdl = 0;
  
  tape_index = 0;
  bit s0,s1,s2,s3,s4,s5,s6,ignore1,ignore2;

  int comparator = integer_expression(a,2,s0,ignore1,ignore2,mdl);
  Guard g = guard_expression(comparator,2,s1,mdl);
  int target = integer_expression(a,2,s2,ignore1,ignore2,mdl);
  Array b = array_expression(a,2,s3,ignore1,ignore2,mdl);
  
  assert mdl < MAXIMUMLENGTH;
  assert s0 && s1 && s2 && s3;
  if (run_guard(g,target)) return b;

  if (bnd < 1) return null;

  Array x = array_expression(a,3,s4,ignore1,ignore2,mdl); bit rx = flip();
  Array y = array_expression(a,3,s5,ignore1,ignore2,mdl); bit ry = flip();
  Array z = array_expression(a,3,s6,ignore1,ignore2,mdl); bit rz = flip();
  
  assert mdl < MAXIMUMLENGTH;

  
  assert s4 && s5 && s6;

  //  if (rz || ry || rx) assert bnd > 0;
  if (rx) {
    assert x.s < a.s;
    int ignore_length = 0;
    x = recursive_expression(x, bnd-1,ignore_length);
  }
  if (ry) {
    assert y.s < a.s;
    int ignore_length = 0;
    y = recursive_expression(y, bnd-1,ignore_length);
  }
  if (rz) {
    assert z.s < a.s;
    int ignore_length = 0;
    z = recursive_expression(z, bnd-1,ignore_length);
  }

  return concatenate3(x,y,z);
}


/*Array specification(Array a,int bnd) {
  if (a.s == 0) return empty_list();
  if (bnd < 1) return null;

  bit s;
  Guard g1 = new Guard(z = car(a,s), o = O_LT);
  Array x = filter(g1,cdr(a,s));
  Guard g2 = new Guard(z = car(a,s), o = O_GT);
  Array z = filter(g2,cdr(a,s));

  Array y = singleton(car(a,s));

  x = specification(x,bnd-1);
  z = specification(z,bnd-1);

  return concatenate3(x,y,z);
  }*/


Array constant_array([int n],int [n] a) {
  return new Array(s = n,A = a);
}

void test_case([int n],int [n] a, int [n] b, bit enforce_embedding) {
  int bnd = n;
  
  int mdl = 0;
  Array k_a = constant_array(a);
  Array o = recursive_expression(k_a, bnd,mdl);

#ifndef ANALYZING
  if (enforce_embedding) {
    assert mdl > (SHORTEST-1);
    assert mdl < MAXIMUMLENGTH;
    int embedding_index = 0;
    repeat (EMBEDDINGLENGTH) {
      if (mdl > embedding_index) assert auxiliary[embedding_index];
      embedding_index++;
    }
  }
#endif
  

  assert o.s == n;
  assert o.A[0::n] == b;
}

harness void main(){
  test_case({},{},0);
  test_case({1},{1},0);
  if (LISTLENGTH > 1) {
    test_case({1,2},{1,2},0);
    test_case({2,1},{1,2},LISTLENGTH == 2);
  }
  if (LISTLENGTH > 2) {
    test_case({1,2,3},{1,2,3},0);
    test_case({1,3,2},{1,2,3},0);
    test_case({2,1,3},{1,2,3},0);
    test_case({2,3,1},{1,2,3},0);
    test_case({2,1,3},{1,2,3},0);
    test_case({3,1,2},{1,2,3},0);
    test_case({3,2,1},{1,2,3},LISTLENGTH == 3);
  }
  assert LISTLENGTH < 4;
}
  

/*
harness void l5() {
  test_case({5,4,3},{3,4,5},3);
}

harness void l6() {
  test_case({1,3,2},{1,2,3},3);
}

harness void l2() {
    test_case({4,5},{4,5},2);
}

harness void l3() {
    test_case({6,1},{1,6},2);
}

harness void l1() {
  test_case({8},{8},1);
}

harness void l0() {
  test_case({},{},1);
}
  

*/
